● 얕은 복사와 깊은 복사_복사 생성자 
- 실제 두개의 값이 생성되는 깊은 복사, 값은 여전히 하나지만 접근 포인터가 둘로 늘어나는 것이 얕은 복사
- 얕은 복사시 두 포인터의 메모리를 해제하는 경우, 두 포인터 모두 한 주소를 가르키는데 이를 두 번 삭제하여 오류가 발생함
- 이를 해결하는 방법 중 하나가 깊은 복사, 복사 생성자 정의하여 깊은 복사를 수행
- 그러나 깊은 복사는 메모리 사용량의 증가를 발생해 메모리 절약(최적화) 단계를 가짐
   ex) r-value 참조, 이동 시멘틱(?) 등

● 대입 연산자 정의
- 포인터를 얕은 복사하면 delete시 오류가 발생, 이를 제거하기 위해 깊은 복사 필요
- 복사 생성자를 이용하여 문제를 위에서 해결, 그러나 이미 동적 할당된 포인터로 복사하는 경우 같은 문제가 발생
- 이를 해결하는 방법이 대입 연산자 재정의(수정), 단순 대입 연산으로 깊은 복사가 가능

● 변환 생성자, 형변환 연산자
- 매개변수가 한 개인 생성자를 의미
- 불필요한 임시 객체를 만들어 냄으로써 프로그램 효율 저하
- 반환형에 맞지 않는 상수 등을 넣어도 선언 되지 않은 객체(임시 객체)를 생성해 동작
- 반환형 앞에 explicit를 작성해 묵시적 변환을 방지할 수 있음
- 형변환 연산자(operator)를 사용하여 원하는 자료형을 반환 가능 
   ex) operate int(void) { return m_nData; } -> CTestData a(10); cout << a << endl; -> 10

● 이름 없는 임시 객체와 r-value 참조
- 연산을 수행할 때 이름 없는 임시 객체가 생성 되었다가 연산 후 소멸
   ex) a = 3 + 2 + 2를 수행할 경우, 3번(?)의 임시 객체가 생성 및 소멸
- 이로인해 순간적인 메모리 사용량이 급증 ( 임시 객체만큼 메모리 추가 사용 )
- r-value 참조를 이용해 위 경우에서 메모리 사용량을 절감할 수 있음
   ex) int &&data = 3 + 4;
- void TestFunc (int Param),  void TestFunc (int &&Param)의 경우 모호성이 발생할 수 있음
- r-value 참조가 필요한 경우는 기본 자료형이 아니라 클래스에 적용될 때

● 이동 시멘틱
- 이동 시멘틱은 이동 생성자와 이동 대입 연산자로 구현됨
- '이름 없는 임시객체'로 증가하는 메모리 사용량을 감소할 목적으로 사용
- 이동 시멘틱은 복사 생성자와 대입 연산자에 r-value 참조를 조합해서 새로운 생성 및 대입 연산자를 만들어 낸것
- 임시 객체에서 얕은 복사를 수행함으로써 성능을 향상시킴 ( 사라질 객체로부터 알맹이는 빼내고 껍데기만 버리는 것처럼 )
- 임시 객체를 생성해 저장될 값을 포인터 멤버에 바로 연결해 사용하는 느낌
   ex) CTestData ( CTestData &&rhs ) : m_nData ( rhs.m_nData ) {}